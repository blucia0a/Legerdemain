Legerdemain - Brandon Lucia - 2011 - University of Washington

Legerdemain (LDM) is a program instrumentation framework.
The purpose of LDM is to provide the ability to:

  *replace/wrap functions
  *monitor program events
  *collecting information
  *support multithreaded programs

The main design goals of LDM are performance, and extensibility.  LDM is
structured as a framework.  To use LDM, a user must write a plugin that
replaces functions, monitors certain events, or collects information.  Which
functions, events, and information are at the discretion of the user.  

The main use case of LDM is to create plugins that implement program analysis
tools.  LDM is a good platform for writing program analysis tools because it
can collect information about programs that cannot be changed, and therefore
can not be instrumented directly by hand.

The Core Functionality section talks about how it does that, via Plugins and
Thread Constructor Plugins.   


Core Functionality:
-------------------
LDM is centered around the idea of plugins.  LDM plugins can do lots of
different things.  Plugins can wrap existing library functions.  Plugins can
provide additional debugging facilities (like thread_constructor).  Plugins can
provide application level profiling and debugging support (like
clientlibs/ConcurrentWatcher).

ldm.sh <your program> runs your program under a default configuration.  It will
load plugins, and provide a debug shell, should you receive any fatal signals.

Plugins
.......
Plugins extend LDM's core functionality.  The simplest kind of plugin is one
that replaces all calls to one function with a function in the plugin.  To do
so, you can use the LDM_REG, LDM_ORIG, and LDM_ORIG_DECL macros.  These mostly
just wrap LD_PRELOAD/dlopen/dlsym stuff, but in my opinion, make them much less
unweildy.  Concretely, to wrap a function (malloc, say):


Pseudo-Code Example 1: Instrumenting calls to malloc.  MallocWatcher.c
=========================================
#include <malloc.h>
#include <stdio.h>

#include "legerdemain.h"

static int malloccount;
LDM_ORIG_DECL(void *,malloc,size_t);
void *malloc(size_t sz){
  malloccount++;
  if( LDM_ORIG(malloc) == NULL ){
    fprintf(stderr,"[MALLOCWATCHER] Forced To register in replacement malloc\n");
    LDM_REG(malloc);
  }
  return LDM_ORIG(malloc)(sz);
}

static void __attribute__ ((constructor)) init();
static void init(){
  LDM_REG(malloc);
  ldmmsg(stderr,"[MALLOCWATCHER] Loading fancy malloc plugin\n");
}

static void __attribute__ ((constructor)) deinit();
static void deinit(){
  ldmmsg(stderr,"[MALLOCWATCHER] Unloading fancy malloc plugin\n");
  ldmmsg(stderr,"[MALLOCWATCHER] Malloc was called %d times\n",malloccount);
}
=========================================

The plugin can be built as a .so, by running

gcc -fPIC -shared -o MallocWatcher.so MallocWatcher.c -ldl

That will produce MallocWatcher.so.    This plugin uses LDM_ORIG_DECL to
declare that the function malloc is being replaced.  Then, in the plugin's
version of malloc(), the original version of malloc() is called using
LDM_ORIG(malloc).  Finally, LDM_REG is called in init() to register the
replacement with LDM.  Note that in some cases, the function you are replacing
may be called during your plugin's initialization.  You need to be sure it
isn't being called before LDM_REG() is called.  The NULL guard in malloc() in
the above example illustrates this.  This will be made more convenient in a
future version of LDM.  ldmmsg(f,s) prints the string s to the FILE *f with
[LDM] before it, so you know where your messages are originating, and they
don't get mixed up with program output.  All this stuff is defined in
legerdemain.h.

To cause LDM to load MallocWatcher.so, run

LDM_CLIENTLIBS=imalloc.so ldm.sh <any program>

Generally, the LDM_PLUGINS variable loads LDM plugins at runtime, within
ldm.sh.  Note that plugins are *not* thread safe, unless you make them thread
safe.  For example, if this plugin is run on a multithreaded program,
malloccount would need to be protected with a lock.  Also note that you must
specify that init and deinit are to be run when the library is loaded by
specifying the constructor and destructor attributes.  This is going to be
cleaned up in a future version of LDM.


Thread-Aware Plugins (TAPs)
..........................
In addition to plugins, TAPs can be built.  A TAP must define a function called
"init_thread".  This function is called by every thread the program spawns
before entering its start_routine.  

The function has the following signature:

void init_thread(void *arg,void *(*start_routine)(void *));

The "arg" argument is the void * argument passed to pthread_create when the
program created the thread.  The "start_routine" argument is the void *(*)(void
*) argument passed to pthread_create.  The routine is exposed to the TAP so a
program may selectively apply instrumentation to only threads executing a
certain function.

A TAP may also specify a thread destructor routine.  There are several things
that are required to ensure thread destructors are correctly handled.  First,
the thread destructor must be declared, and associated with a special
destructor identifier using LDM_THD_DTR_DECL(id,func).  Second, in the plugin
initializer (the function declared with LDM_PLUGIN_INIT), you must call
LDM_REGISTER_THD_DTR(id,func).  Finally, in the init_thread function, each
thread must call LDM_INSTALL_THD_DTR(id), to enable the destructor.

TAPs are conceptually a "subclass" of regular plugins.  They can still do all
the things that plugins can do (use LDM_ORIG_DECL, etc), but they also allow
you to expose the init_thread function.  TAPs are specified as a colon
separated list via the LDM_TAPS (not LDM_PLUGINS, like regular plugins)
environment variable, and are loaded by ldm's thread_constructor module, when
it is loaded by LDM.  

An example of a TAP is in clientlibs/NullThreadWatcher.  It illustrates a
thread_init function, and the establishment of a thread destructor.


Sampled TAPs (sTAPs)
....................
LDM provides support to temporally sample events in your program.  There is a
simple tutorial example illustrating how to use this feature in
clientlibs/NullSampledWatcher.  There are several steps:

1)First write a TAP (see previous section).  

2)Call sampled_thread_monitor_init() to initialize the sampling subsystem when
  you intialize your plugin (in your LDM_PLUGIN_INIT function).  

3)Register threads with the sampling system as they are created.  Do this using
  sampled_thread_monitor_thread_init(), which should be called from your plugin's
  thread initialization function (thread_init()).  

4)Create a destructor in your TAP (see previous section).  In your plugin's
  thread destructor, you need to call sampled_thread_monitor_thread_deinit().
  This is important, as if you do not, your program will crash.

5)In order to do anything in your sTAP, you need to register a
  function that gets called when the sampling subsystem 'poke's your threads.  To
  do so, you need to write a function that gets passed as the second argument to 
  sampled_thread_monitor_init(). The returns void, and is passed two
  arguments by the sampling subsystem when it is called: a SamplingState
  argument, that says whether sampling is being turned on (SAMPLE_ON) or off
  (SAMPLE_OFF); and a ucontext_t * argument, which is the architectural context
  of the thread at the point just before it was poked. 

Refer to clientlibs/NullSampledWatcher/NullSampledWatcher.c for an illustrative 
example of a sTAP.


DEBUGGING SUPPORT:
------------------
LDM will catch fatal signals and drop to a shell.  The shell has a few useful commands, to look at memory addresses, query for live variables, etc. 'help' in the shell will overview the commands.  To force the debug shell at startup, you can specify LDM_DEBUG=1 in your environment before running ldm.sh.


ELF/DWARF Support:
------------------
LDM has rudimentary support for looking at dwarf/elf information.  Running ldm,
you can type 'help'.  This will present you with a list of possible commands,
most of which related to debug info.

libdwarfclient is used by libldm to access dwarf information in elf program
binaries.  dwarfinfo is a standalone program that can be used to access
dwarf debugging information from the the command line.  It is primarily 
useful in 3 ways right now.
1)using options -g -e<executable> -f<source file> -l<source line> it will show the 
  instruction address of the specified file and line
2)adding the -c option to the command line in 1), information about the compilation
  unit in which the code point resides will be printed
3)using the -p option dumps all the dwarf debug information in the binary


APPENDIX A: Design Notes
------------------------
Driven by performance, LDM does not use the dynamic compilation strategy used
by Dynamo/DynamoRIO/Pin. LDM is different in that there is no fixed overhead to
running a program with LDM, like there is with Pin (due to dynamic compilation,
code caching, etc). Instead, LDM runs programs with zero overhead, unless
instructed otherwise by a program analysis plugin.  The cost of this design
decision is that many fine-grained events that are accessible to Pin are
fundamentally uninstrumentable by LDM.


APPENDIX B: TODO
----------------
Add integrated support for user defined watchpoints, via drprobe (github.com/blucia0a/drprobe).
